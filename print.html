<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chess Programming in Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introductions.html">Introductions</a></li><li class="chapter-item expanded affix "><a href="setup.html">Setup</a></li><li class="chapter-item expanded affix "><li class="part-title">The Basics</li><li class="chapter-item expanded "><a href="boardrepr/boardrepr.html"><strong aria-hidden="true">1.</strong> Board Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="boardrepr/keepingtrack/keepingtrack.html"><strong aria-hidden="true">1.1.</strong> Keeping Track of Pieces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="boardrepr/keepingtrack/bitsandpieces.html"><strong aria-hidden="true">1.1.1.</strong> Bits and Pieces</a></li><li class="chapter-item expanded "><a href="boardrepr/keepingtrack/squaringaway.html"><strong aria-hidden="true">1.1.2.</strong> Squaring Away the Code</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Move Generation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Evaluation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Search</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Universal Chess Interface</div></li><li class="chapter-item expanded affix "><li class="part-title">Advanced</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Room for Improvement</div></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="termsandnotation.html"><strong aria-hidden="true">7.</strong> Terms and Notation</a></li><li class="chapter-item expanded affix "><a href="further.html">Further Reading</a></li><li class="chapter-item expanded affix "><a href="credits.html">Credits</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Chess Programming in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introductions"><a class="header" href="#introductions">Introductions</a></h1>
<blockquote>
<p>üèóÔ∏è üöß <em>This book is currently under construction.</em> üöß üèóÔ∏è</p>
</blockquote>
<p><strong>enpassant</strong> is an educational chess library written in Rust. This book is intended to be a journey into the rabbit hole of chess programming, but it is coincidentally a way of learning <a href="https://doc.rust-lang.org/rust-by-example/" target="_blank">Rust by Example</a>. It will not be a comprehensive overview of Rust (see <a href="https://doc.rust-lang.org/book/" target="_blank">the official Rust book</a>), but it only assumes a barebones knowledge of the language. I myself don't know much more than the basics, so I've asked one of my friends who happens to be an expert in Rust to accompany us on our journey.</p>
<blockquote>
<p><strong>FRIEND:</strong> ...</p>
</blockquote>
<p>Why don't you say hi?</p>
<blockquote>
<p><strong>FRIEND:</strong> ...</p>
</blockquote>
<p>Might as well get acquainted, the three of us have got a long road ahea-</p>
<blockquote>
<p><strong>FRIEND:</strong> I just lost 100 rating points playing blitz on Lichess.</p>
</blockquote>
<p>Oh. I see.</p>
<p>By the end of this book, you will be able to not only implement a chess engine in Rust, but in any language that you're comfortable in. In this book we will go over five fundamental questions in chess programming:</p>
<ol>
<li><a href="boardrepr/boardrepr.html">How do we represent chess in a way that the computer understands?</a></li>
<li><a href="movegeneration/movegeneration.html">In a given position, how does a computer know what its moves are?</a></li>
<li><a href="eval/eval.html">How should the computer decide how good a given position is?</a></li>
<li><a href="search/search.html">How should the computer search through all of its moves?</a></li>
<li><a href="uci/uci.html">How can the computer return its chose move in a universal format?</a></li>
</ol>
<p>Answering these questions provide at least the basics of a working chess engine. From there you'll be able to delve into deeper topics and make an even more advanced chess engine.</p>
<p>Let's get started, shall we?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<blockquote>
<p><strong>FRIEND:</strong> Did you check if our guest has already packed for our trip?</p>
</blockquote>
<p>Oops.</p>
<p>Before we go, make sure that you have <a target="_blank" href="https://www.rust-lang.org/tools/install">Rust installed</a> on your machine.</p>
<p>Then, start by creating a new project in your preferred directory using <code>cargo</code>, Rust's package manager.</p>
<pre><code class="language-text">&gt; cargo new --lib chess
&gt; cd chess
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Wait hold on. Do they know what <code>cargo</code> even is?</p>
</blockquote>
<p>To be honest, I'm not even sure what <code>cargo</code> is.</p>
<blockquote>
<p><strong>FRIEND:</strong> Installing Rust from the link above installs the language as well as three important parts of the Rust toolchain: <code>rustc</code>, <code>rustup</code>, and <code>cargo</code>.</p>
</blockquote>
<p>What do those three things do?</p>
<blockquote>
<p><strong>FRIEND:</strong> <code>rustc</code> is the Rust's compiler, <code>rustup</code> is the installer for Rust and its tools, and <code>cargo</code> is Rust's package manager. Once you run the commands given above, you've created a project named &quot;chess&quot; that is managed by <code>cargo</code>. Your directory should look like this.</p>
</blockquote>
<pre><code class="language-text">.
‚îî‚îÄ‚îÄ chess/
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
    ‚îî‚îÄ‚îÄ Cargo.toml
</code></pre>
<p>Gotcha. Now we're ready to go?</p>
<blockquote>
<p><strong>FRIEND:</strong> Ready if you two are.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="board-representation"><a class="header" href="#board-representation">Board Representation</a></h1>
<center><strong>How do we represent chess in a way that the computer understands?</strong></center></br>
<p>How would you answer this question?</p>
<blockquote>
<p><strong>FRIEND:</strong> Well, it sounds like we need to encode the rules of chess in our program.</p>
</blockquote>
<p>Yep, and it's important that we do it perfectly, or else our program will be buggy. It's also worth considering efficiency, since a faster chess engine is a strong one.</p>
<blockquote>
<p><strong>FRIEND:</strong> Well, it shouldn't be too hard. There's an 8x8 board of squares, a white and black side, each side gets eight pawns, two rooks, two bishops, two knights, a king and a queen...</p>
</blockquote>
<p>What about castling‚Äî</p>
<blockquote>
<p><strong>FRIEND:</strong> That thing where the king and rook swap places? That seems simple enou‚Äî</p>
</blockquote>
<p>There are two rooks.</p>
<blockquote>
<p><strong>FRIEND:</strong> Right, the king can castle in either direction‚Äî</p>
</blockquote>
<p>Not always though.</p>
<blockquote>
<p><strong>FRIEND:</strong> Well, the king loses castling rights if he moves, and he loses castling rights on a side if the rook on that side moves.</p>
</blockquote>
<p>He also can't castle temporarily if an enemy is attacking the squares that he must move through to get to his castling square.</p>
<blockquote>
<p><strong>FRIEND:</strong> Wait, wha‚Äî</p>
</blockquote>
<p>And what about promotions?</p>
<blockquote>
<p><strong>FRIEND:</strong> Uhhh, the pawns can upgrade to other pieces if they reach the end of the board... and there are two ends since white and black go in opposite directions‚Äî</p>
</blockquote>
<p>Pawns can also move two squares from their starting squares too.</p>
<blockquote>
<p><strong>FRIEND:</strong> Oh, yeah. Forgot about that.</p>
</blockquote>
<p>And pawns that move two can be diagonally captured on and only on the next turn by adjacent enemy pawns.</p>
<blockquote>
<p><strong>FRIEND:</strong> Huh???</p>
</blockquote>
<p>It's called <a href="https://en.wikipedia.org/wiki/En_passant" target="_blank"><em><em>en passant</em></em></a>.</p>
<blockquote>
<p><strong>FRIEND:</strong> ...</p>
</blockquote>
<p>Not as simple as you thought, huh?</p>
<blockquote>
<p><strong>FRIEND:</strong> There are a <em>lot</em> of little rules. Maybe I'll have to do a <a href="https://en.wikipedia.org/wiki/Rules_of_chess" target="_blank">refresher</a>.</p>
</blockquote>
<p>It's definitely worth the effort. Still, if you don't know them all, it's no big deal. I'll make sure we cover all of them on our journey. However, it will be useful to know <a href="boardrepr/../termsandnotation.html">some chess terminalogy and notation</a>. Let's move forward then.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keeping-track-of-pieces"><a class="header" href="#keeping-track-of-pieces">Keeping Track of Pieces</a></h1>
<p>Inside our project directory, let's create a new file in <code>src</code>. We can call it <code>board.rs</code>.</p>
<pre><code class="language-text">&gt; touch src/board.rs
</code></pre>
<p>How would you go about representing pieces on a chess board?</p>
<blockquote>
<p><strong>FRIEND:</strong> Well, a chessboard is an 8x8 grid, and each square can hold at most one piece. It kinda sounds like 2D array. We should create a struct that contains everything regarding the state of a chessboard.</p>
</blockquote>
<pre><code class="language-rust noplayground">pub struct Board {
    pieces: [[SomethingGoesHere; 8]; 8]
}
</code></pre>
<p>Typically we use an enum to distinguish between different types of pieces. Does Rust have something like that?</p>
<blockquote>
<p><strong>FRIEND:</strong> Yep, check this out.</p>
</blockquote>
<pre><code class="language-rust  noplayground">pub enum Color {
    White,
    Black,
}

pub enum Role {
    Pawn,
    Knight,
    Bishop,
    Rook,
    Queen,
    King,
}
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Here we strictly defined a set of variants for each enum. <code>Color</code> can only ever be <code>White</code> or <code>Black</code>, and <code>Role</code> can ever only be one of those pieces. We can then put this enums together to make a full piece.</p>
</blockquote>
<pre><code class="language-rust noplayground">pub struct Piece {
    color: Color,
    role: Role,
}

pub struct Board {
    board: [[Option&lt;Piece&gt;; 8]; 8]
}
</code></pre>
<p>Whoa, what did you just put in our board array?</p>
<blockquote>
<p><strong>FRIEND:</strong> Well, a chessboard isn't entirely made up of pieces‚Äîthere are empty squares. So I made the board a 2D  array of <code>Option&lt;Piece&gt;</code>, which is also an enum of two variants: <code>Some</code> and <code>None</code>.  If an index in our array doesn't contain a piece, i.e. it's an empty square, it will hold <code>None</code>. But if it has a piece, at the index there will be <code>Some(p)</code>, where <code>p</code> is a <code>Piece</code>. Alternatively, we could've done this...</p>
</blockquote>
<pre><code class="language-rust noplayground">pub enum Piece {
    Empty,
    Occupied(Color, Role),
}

pub struct Board {
    board: [[Piece; 8]; 8]
}
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> ...but it's sort of just a worse version of <code>Option</code>, so we'll stick with the other definition.</p>
</blockquote>
<p>Gotcha. Let's also define ranks and files on the chessboard.</p>
<pre><code class="language-rust noplayground">pub enum Rank {
    First = 0,
    Second = 1,
    Third = 2,
    Fourth = 3,
    Fifth = 4,
    Sixth = 5,
    Seventh = 6
    Eighth = 7,
}

pub enum File {
    A = 0,
    B = 1,
    C = 2,
    D = 3,
    E = 4,
    F = 5,
    G = 6,
    H = 7,
}
</code></pre>
<p>And we can assign values to our enum variants like we might in C to use these enums as indices into our <code>Board</code>?</p>
<blockquote>
<p><strong>Friend:</strong> Sounds like a good idea. Now we can start writing functions for our new <code>Board</code> struct, right?</p>
</blockquote>
<p>Not quite. There's another board representation concept in chess programming that I want to show you first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bits-and-pieces"><a class="header" href="#bits-and-pieces">Bits and Pieces</a></h1>
<p>So far we're able to represent a chessboard like this.</p>
<pre><code class="language-text">[[_, _, _, _, p, _, _, _],            8  . . . . . . . .
 [_, _, N, _, _, _, _, _],            7  . . . . . . . .
 [p, _, _, _, _, _, _, _],            6  . . . . . . . .
 [_, p, _, p, _, _, _, _],            5  . . . . . . . .
 [_, _, _, _, _, _, _, _],   -----&gt;   4  . p . p . . . .
 [_, _, _, _, _, _, _, _],            3  p . . . . . . .
 [_, _, _, _, _, _, _, _],            2  . . N . . . . .
 [_, _, _, _, _, _, _, _]]            1  . . . . p . . .

                                         a b c d e f g h
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Wait, it's upside down?</p>
</blockquote>
<p>Yep, because index 0 in our array maps to the first rank on a chessboard.</p>
<blockquote>
<p><strong>FRIEND:</strong> Might have to stare at that for a while to understand it.</p>
</blockquote>
<pre><code class="language-text">[[a1, b1, c1, d1, e1, f1, g1, h1],
 [a2, b2, c2, d2, e2, f2, g2, h2],
 [a3, b3, c3, d3, e3, f3, g3, h3],
 [a4, b4, c4, d4, e4, f4, g4, h4],
 [a5, b5, c5, d5, e5, f5, g5, h5],
 [a6, b6, c6, d6, e6, f6, g6, h6],
 [a7, b7, c7, d7, e7, f7, g7, h7],
 [a8, b8, c8, d8, e8, f8, g8, h8]]
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Ah. That helps.</p>
</blockquote>
<blockquote>
<p><strong>FRIEND:</strong> You know, after some thought, this 2D array seems like a good way to check what's on a square. If I wanted to see what's on <code>c2</code>, then all I'd have to do is index using <code>Rank::Second</code> and <code>File::C</code>. But what if I wanted to ask, &quot;Is there a knight?&quot; Would I have to scan the entire 2D array?</p>
</blockquote>
<p>You're catching on to one of the cons of this approach. All <em>square-centric</em> approaches are good at telling you what's on a square, but not where the pieces are (at least without scanning the entire board). This specific representation method is known as a <em>mailbox</em>.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>The counterpart of square-centric is <em>piece-centric</em>. Piece-centric representations are good at answering, &quot;Where are the pieces?&quot; The most common method of piece-centric representation is the <em>bitboard</em>.<sup class="footnote-reference"><a href="#2">2</a></sup> Here are some examples from the starting position of a chess game.</p>
<pre><code class="language-text">8  . x . . . . x .         8  . . . . . . . .         8  . . . . . . . .
7  . . . . . . . .         7  . . . . . . . .         7  . . . . . . . .
6  . . . . . . . .         6  . . . . . . . .         6  . . . . . . . .
5  . . . . . . . .         5  . . . . . . . .         5  . . . . . . . .
4  . . . . . . . .         4  . . . . . . . .         4  . . . . . . . .
3  . . . . . . . .         3  . . . . . . . .         3  . . . . . . . .
2  . . . . . . . .         2  x x x x x x x x         6  . . . . . . . .
1  . x . . . . x .         1  x x x x x x x x         1  . x . . . . x .

   a b c d e f g h            a b c d e f g h            a b c d e f g h

bitboard of knights        bitboard of white pieces   bitboard of white knights
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Whoa, these are a lot more specific than the mailbox we had earlier. Also, the pieces are symbolized by <code>x</code>'s now?</p>
</blockquote>
<p>Yep, bitboards are essentially a binary string, a 64-bit integer, where the ones or <code>x</code>'s represent pieces that are present, and the zeroes or periods represent the absence of pieces.</p>
<blockquote>
<p><strong>FRIEND:</strong> So, not an empty square.</p>
</blockquote>
<p>Exactly. Notice that a zero in the bitboard of white's pieces symbolizes where there <em>aren't</em> white pieces, not that there aren't any pieces at all.</p>
<blockquote>
<p><strong>FRIEND:</strong> I see what you're doing. If we had a bitboard for every piece, we would know where all the pieces on a chessboard are!</p>
</blockquote>
<p>Pretty much. There are many different ways to use bitboards to keep track of all the information we need. In this book, we'll keep track of two color bitboards (all white pieces and all black pieces), and then five piece type (<code>Role</code>) bitboards (one for each piece, except for the king<sup class="footnote-reference"><a href="#3">3</a></sup>). Let's go back to the example bitboards. If you're familiar with binary/bitwise operations, you'll find bitboards intuitive.</p>
<pre><code class="language-text">8  . x . . . . x .         8  . . . . . . . .         8  . . . . . . . .
7  . . . . . . . .         7  . . . . . . . .         7  . . . . . . . .
6  . . . . . . . .         6  . . . . . . . .         6  . . . . . . . .
5  . . . . . . . .         5  . . . . . . . .         5  . . . . . . . .
4  . . . . . . . .    &amp;    4  . . . . . . . .    =    4  . . . . . . . .
3  . . . . . . . .   AND   3  . . . . . . . .         3  . . . . . . . .
2  . . . . . . . .         2  x x x x x x x x         6  . . . . . . . .
1  . x . . . . x .         1  x x x x x x x x         1  . x . . . . x .

   a b c d e f g h            a b c d e f g h            a b c d e f g h

knights                    white pieces               white knights


8  . . . . . . . .         8  x x x x x x x x         8  x x x x x x x x
7  . . . . . . . .         7  x x x x x x x x         7  x x x x x x x x
6  . . . . . . . .         6  . . . . . . . .         6  . . . . . . . .
5  . . . . . . . .         5  . . . . . . . .         5  . . . . . . . .
4  . . . . . . . .    |    4  . . . . . . . .    =    4  . . . . . . . .
3  . . . . . . . .   OR    3  . . . . . . . .         3  . . . . . . . .
2  x x x x x x x x         2  . . . . . . . .         6  x x x x x x x x
1  x x x x x x x x         1  . . . . . . . .         1  x x x x x x x x

   a b c d e f g h            a b c d e f g h            a b c d e f g h

white pieces               black pieces               all pieces


                           8  . . . . . . . .         8  x x x x x x x x
                           7  . . . . . . . .         7  x x x x x x x x
                           6  . . . . . . . .         6  x x x x x x x x
                           5  . . . . . . . .         5  x x x x x x x x
                      !    4  . . . . . . . .    =    4  x x x x x x x x
                     NOT   3  . . . . . . . .         3  x x x x x x x x
                           2  x x x x x x x x         6  . . . . . . . .
                           1  x x x x x x x x         1  . . . . . . . .

                              a b c d e f g h            a b c d e f g h

                           white pieces               everything but white pieces
</code></pre>
<p>Just using these operations, we can access all the information we could need about the pieces on a board. At an instruction level, this is also pretty cheap‚Äîbitwise operations typically have their own instruction.</p>
<p>To remain flexible, it's useful to have both piece-centric and square-centric representations of the board, even if they're redundant.</p>
<blockquote>
<p><strong>FRIEND:</strong> Fine with me. Let's start writing this in Rust!</p>
</blockquote>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.chessprogramming.org/Mailbox">&quot;Mailbox&quot;, Chess Programming Wiki</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://www.chessprogramming.org/Bitboards">&quot;Bitboards&quot;, Chess Programming Wiki</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Since there is only one king on each side, we need not keep an entire bitboard for the kings. Instead we'll just keep track of two squares, one for each king.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="squaring-away-the-code"><a class="header" href="#squaring-away-the-code">Squaring Away the Code</a></h1>
<blockquote>
<p><strong>FRIEND:</strong> Let's add to our <code>Board</code> struct.</p>
</blockquote>
<pre><code class="language-rust  noplayground">pub struct Board {
    colors: [Bitboard; 2],
    roles: [Bitboard; 5],
    mailbox: Mailbox
};
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Our colors and roles bitboards are stored in arrays, and we can use our enums to index into them. Our old <code>Option&lt;Piece&gt;</code> array can be encapsulated into a <code>Mailbox</code> struct that we'll soon define.</p>
</blockquote>
<pre><code class="language-rust  noplayground">#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Default)]
pub struct Bitboard(u64);

impl Bitboard { ... }
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Our bitboard is just represented by a 64-bit number, and we don't care about the sign of our board, so we'll use a <code>u64</code>. For simplicity's sake, we're using a tuple struct, where we can access the field by index (<code>b.0</code>, where <code>b</code> is a <code>Bitboard</code>).</p>
</blockquote>
<pre><code class="language-rust  noplayground">impl Bitboard {
    pub fn new(value: u64) -&gt; Self {
        Bitboard(value)
    }

    pub fn is_empty(self) -&gt; bool {
        self.0 == 0u64
    }

    pub fn is_any(self) -&gt; bool {
        self.0 != 0u64
    }

    ...
}
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> We'll also add some useful constants (called masks) for specific bitboards that are useful to have in future functions.</p>
</blockquote>
<pre><code class="language-rust  noplayground">impl Bitboard {
    const EMPTY_MASK: u64 = 0x0000_0000_0000_0000;

    const FULL_MASK: u64 = 0xFFFF_FFFF_FFFF_FFFF;

    const FILE_MASKS: [u64; 8] = [
        0x8080_8080_8080_8080,
        0x4040_4040_4040_4040,
        0x2020_2020_2020_2020,
        0x1010_1010_1010_1010,
        0x0808_0808_0808_0808,
        0x0404_0404_0404_0404,
        0x0202_0202_0202_0202,
        0x0101_0101_0101_0101,
    ];

    const RANK_MASKS: [u64; 8] = [
        0xFF00_0000_0000_0000,
        0x00FF_0000_0000_0000,
        0x0000_FF00_0000_0000,
        0x0000_00FF_0000_0000,
        0x0000_0000_FF00_0000,
        0x0000_0000_00FF_0000,
        0x0000_0000_0000_FF00,
        0x0000_0000_0000_00FF,
    ];

    const SINGULAR_MASKS: [u64; 64] = {
        let mut masks: [u64; 64] = [1u64; 64];
        let mut i: usize = 0;
        while i &lt; 64 {
            masks[i] = 1u64 &lt;&lt; i;
            i += 1;
        }
        masks
    };

    pub fn new(value: u64) -&gt; Self { ... }

    ...

    pub fn from_square( ? ) -&gt; Self {
        todo!()
    }

    pub fn from_rank(r: Rank) -&gt; Self {
        Bitboard(Self::RANK_MASKS[r as usize])
    }

    pub fn from_file(f: File) -&gt; Self {
        Bitboard(Self::FILE_MASKS[f as usize])
    }

    pub fn empty() -&gt; Self {
        Bitboard(Self::EMPTY_MASK)
    }

    pub fn full() -&gt; Self {
        Bitboard(Self::FULL_MASK)
    }
}
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Most of these masks are self-explanatory. <code>FILE_MASKS</code> and <code>RANK_MASKS</code> are indexable by row and file. <code>SINGULAR_MASKS</code> is indexable by square, but notice that it is constructed within a block, in which computation is done to create an array of masks that correspond with their respective index.</p>
</blockquote>
<p>As opposed to writing out 64 lines of masks like we did for rank and file?</p>
<blockquote>
<p><strong>FRIEND:</strong> Exactly.</p>
<p><strong>FRIEND:</strong> You also might have noticed that I've left the <code>from_square</code> method blank. We'll get back to it soon, since it's dependent on how we implement squares.</p>
<p><strong>FRIEND:</strong> We're also going to implement some traits<sup class="footnote-reference"><a href="#1">1</a></sup> for our <code>Bitboard</code> struct to make it easier to do bitwise operations.</p>
</blockquote>
<pre><code class="language-rust  noplayground">use std::ops::{BitOr, BitAnd, BitXor, Not};

...

impl BitOr for Bitboard {
    type Output = Bitboard;

    fn bitor(self, rhs: Self) -&gt; Self::Output {
        Bitboard(self.0 | rhs.0)
    }
}

impl BitAnd for Bitboard {
    type Output = Bitboard;

    fn bitand(self, rhs: Self) -&gt; Self::Output {
        Bitboard(self.0 &amp; rhs.0)
    }
}

impl BitXor for Bitboard {
    type Output = Bitboard;

    fn bitxor(self, rhs: Self) -&gt; Self::Output {
        Bitboard(self.0 ^ rhs.0)
    }
}

impl Not for Bitboard {
    type Output = Bitboard;

    fn not(self) -&gt; Self::Output {
        Bitboard(!self.0)
    }
}
</code></pre>
<p>Sweet. So now we can perform operations like these.</p>
<pre><code class="language-rust  noplayground">let b1 = Bitboard::from_file(File::G);
let b2 = Bitboard::from_rank(Rank::Fifth);
</code></pre>
<pre><code class="language-text">                8  . . . . . . x . 
                7  . . . . . . x . 
                6  . . . . . . x . 
                5  x x x x x x x x 
b1 | b2    =    4  . . . . . . x . 
                3  . . . . . . x . 
                2  . . . . . . x . 
                1  . . . . . . x . 
        
                   a b c d e f g h


                8  . . . . . . . . 
                7  . . . . . . . . 
                6  . . . . . . . . 
                5  . . . . . . x . 
b1 &amp; b2    =    4  . . . . . . . . 
                3  . . . . . . . . 
                2  . . . . . . . . 
                1  . . . . . . . . 
        
                   a b c d e f g h
</code></pre>
<blockquote>
<p><strong>FRIEND:</strong> Yep.</p>
<p><strong>FRIEND:</strong> Now we need to go back and implement our <code>from_square</code> method.</p>
</blockquote>
<p>Most chess engines and libraries just type alias a <code>Square</code> to an integer type.</p>
<blockquote>
<p><strong>FRIEND:</strong> That could work, but it might be safer and cleaner if we wrap that integer in a struct. Doing this would allow us to write methods that also guarantee that we only have valid squares in our program, i.e. squares whose index on the board only range from 0 to 63 (squares with indices 64 and above don't make much sense).</p>
</blockquote>
<pre><code class="language-rust  noplayground">#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Default)]
pub struct Square(u8);

impl Square {
    pub const COUNT: usize = 64;

    pub fn new(value: u8) -&gt; Self {
        assert!(value &lt; 64, &quot;value must be between 0 and 64&quot;);
        Square::new_unchecked(value)
    }

    pub fn new_unchecked(value: u8) -&gt; Self {
        Square(value)
    }

    pub fn from_file_and_rank(f: File, r: Rank) -&gt; Self {
        let file_index = f as u8;
        let rank_index = r as u8;
        Square(rank_index * 8 + file_index)
    }

    pub fn from_singular_bitboard(b: Bitboard) -&gt; Self {
        assert!(b.is_singular());
        Square(b.0.trailing_zeros() as u8)
    }

    pub fn index(self) -&gt; usize {
        self.0 as usize
    }

    pub fn file(self) -&gt; File {
        File::new(self.0 % 8)
    }

    pub fn rank(self) -&gt; Rank {
        Rank::new(self.0 / 8)
    }

    pub fn coords(self) -&gt; (File, Rank) {
        (self.file(), self.rank())
    }

    pub fn flipped(self) -&gt; Self {
        Square(63 - self.0)
    }
}

</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Traits: Defining Shared Behavior - The Rust Programming Language</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terms-and-notation"><a class="header" href="#terms-and-notation">Terms and Notation</a></h1>
<p>Conventionally, unless otherwise specified, boards will be displayed from white's perspective.</p>
<p>A <em>rank</em> is a row on a chessboard.</p>
<pre><code class="language-text">8  . . . . . . . . 
7  . . . . . . . . 
6  . . . . . . . . 
5  x x x x x x x x 
4  . . . . . . . . 
3  . . . . . . . . 
2  . . . . . . . . 
1  . . . . . . . . 



the fifth rank
</code></pre>
<br/>
<p>A <em>file</em> is a column on a chessboard.</p>
<pre><code class="language-text">   . . . . . . x . 
   . . . . . . x . 
   . . . . . . x . 
   . . . . . . x . 
   . . . . . . x . 
   . . . . . . x . 
   . . . . . . x . 
   . . . . . . x . 

   a b c d e f g h

the g-file
</code></pre>
<br/>
<p>A <em>square</em> is named by its file then rank.</p>
<pre><code class="language-text">8  . . . . . . . . 
7  . . . . . . . . 
6  . . . . . . . . 
5  . . . . . . x . 
4  . . . . . . . . 
3  . . . . . . . . 
2  . . . . . . . . 
1  . . . . . . . . 
   
   a b c d e f g h

the g5 square
</code></pre>
<br/>
<p>The coordinates flip if we are viewing the board from black's perspective.</p>
<pre><code class="language-text">1  . . . . . . . . 
2  . . . . . . . . 
3  . . . . . . . . 
4  . . . . . . . . 
5  . x . . . . . . 
6  . . . . . . . . 
7  . . . . . . . . 
8  . . . . . . . . 
   
   h g f e d c b a

the same g5 square from black's perspective
</code></pre>
<br/>
<p>Piece moves are represented by the piece letter and the square it moved to.</p>
<pre><code class="language-text">8  . . . . . . . .            8  . . . . . . . . 
7  . . . . . . . .            7  . . . . . . . .    
6  . . . . . . . .            6  . . . . . . . .
5  . . . . . . . .    Ng5     5  . . . . . . N .
4  . . . . . . . .   -----&gt;   4  . . . . . . . .
3  . . . . . N . .            3  . . . . . . . . 
2  . . . . . . . .            2  . . . . . . . . 
1  . . . . . . . .            1  . . . . . . . . 
   
   a b c d e f g h               a b c d e f g h

a knight on f3 moving to g5

'N' = knight, 'B' = bishop, 'R' = rook, 'Q' = queen, 'K' = king
</code></pre>
<br/>
<p>Pawn moves are notated without a letter.</p>
<pre><code class="language-text">8  . . . . . . . .            8  . . . . . . . . 
7  . . . . . . . .            7  . . . . . . . .    
6  . . . . . . . .            6  . . . . . . . .
5  . . . . . . . .     g5     5  . . . . . . P .
4  . . . . . . P .   -----&gt;   4  . . . . . . . .
3  . . . . . . . .            3  . . . . . . . . 
2  . . . . . . . .            2  . . . . . . . . 
1  . . . . . . . .            1  . . . . . . . . 
   
   a b c d e f g h               a b c d e f g h

a white pawn on g4 moving to g5
</code></pre>
<br/>
<p>Captures are denoted with an <code>x</code> between the piece and the square.</p>
<pre><code class="language-text">8  . . . . . . . .            8  . . . . . . . . 
7  . . . . . . . .            7  . . . . . . . .    
6  . . . . . . . .            6  . . . . . . . .
5  . . . . . . b .    Nxg5    5  . . . . . . N .
4  . . . . . . . .   -----&gt;   4  . . . . . . . .
3  . . . . . N . .            3  . . . . . . . . 
2  . . . . . . . .            2  . . . . . . . . 
1  . . . . . . . .            1  . . . . . . . . 
   
   a b c d e f g h               a b c d e f g h

a knight captures a bishop on g5
</code></pre>
<br/>
<p>Pawn captures are denoted by the square from which the pawn originated.</p>
<pre><code class="language-text">8  . . . . . . . .            8  . . . . . . . . 
7  . . . . . . . .            7  . . . . . . . .    
6  . . . . . . . .            6  . . . . . . . .
5  . . . . . . q .    fxg5    5  . . . . . . P .
4  . . . . . P . .   -----&gt;   4  . . . . . . . .
3  . . . . . . . .            3  . . . . . . . . 
2  . . . . . . . .            2  . . . . . . . . 
1  . . . . . . . .            1  . . . . . . . . 
   
   a b c d e f g h               a b c d e f g h

a pawn captures a queen on g5
</code></pre>
<br/>
<p>If there are multiple moves by the same piece type to the same square, the file and/or rank of origin is used.</p>
<pre><code class="language-text">8  . . . . . . . .            8  . . . . . . . . 
7  . . . . . . . .            7  . . . . . . . .    
6  . . . . . . . .            6  . . . . . . . .
5  . . R . . . . R    Rhg5    5  . . R . . . R .
4  . . . . . . . .   -----&gt;   4  . . . . . . . .
3  . . . . . . . .            3  . . . . . . . . 
2  . . . . . . . .            2  . . . . . . . . 
1  . . . . . . . .            1  . . . . . . . . 
   
   a b c d e f g h               a b c d e f g h

8  . . . . . . R .            8  . . . . . . . . 
7  . . . . . . . .            7  . . . . . . . .    
6  . . . . . . . .            6  . . . . . . . .
5  . . . . . . . .    R8g5    5  . . . . . . R .
4  . . . . . . . .   -----&gt;   4  . . . . . . . .
3  . . . . . . . .            3  . . . . . . . . 
2  . . . . . . . .            2  . . . . . . . . 
1  . . . . . . R .            1  . . . . . . R . 
   
   a b c d e f g h               a b c d e f g h

8  . . . . . . . .            8  . . . . . . . . 
7  . . . . . . . .            7  . . . . . . . .    
6  . . . . . . . .            6  . . . . . . . .
5  . . R . . . . .    Rcg5    5  . . . . . . R .
4  . . . . . . . .   -----&gt;   4  . . . . . . . .
3  . . . . . . . .            3  . . . . . . . . 
2  . . . . . . . .            2  . . . . . . . . 
1  . . . . . . R .            1  . . . . . . R . 
   
   a b c d e f g h               a b c d e f g h

default to using file
</code></pre>
<br/>
<p><code>O-O</code> means castle kingside, <code>O-O-O</code> means castle queenside</p>
<pre><code class="language-text">8  . . . . . . . .            8  . . . . . . . . 
7  . . . . . . . .            7  . . . . . . . .    
6  . . . . . . . .            6  . . . . . . . .
5  . . . . . . . .    O-O     5  . . . . . . . .
4  . . . . . . . .   -----&gt;   4  . . . . . . . .
3  . . . . . . . .            3  . . . . . . . . 
2  . . . . . . . .            2  . . . . . . . . 
1  . . . . K . . R            1  . . . . . R K . 
   
   a b c d e f g h               a b c d e f g h
</code></pre>
<br/>
<div style="break-before: page; page-break-before: always;"></div><h1 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credits"><a class="header" href="#credits">Credits</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
